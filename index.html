<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISS 3D Tracker - Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-panel {
            position: absolute; bottom: 30px; left: 30px;
            background: rgba(5, 10, 20, 0.7); backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 255, 255, 0.2); border-radius: 12px;
            padding: 20px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.05); pointer-events: none;
        }
        
        #ui-panel h1 { margin: 0 0 15px 0; font-size: 1.1rem; color: #0ff; letter-spacing: 2px; }
        .data-row { margin: 8px 0; font-size: 0.9rem; display: flex; justify-content: space-between; width: 260px; }
        .data-label { color: #888; }
        .data-value { font-family: monospace; color: #fff; text-shadow: 0 0 8px rgba(0,255,255,0.5); font-size: 1rem;}

        #city-info {
            position: absolute; top: 30px; right: -350px; width: 280px;
            background: rgba(5, 10, 20, 0.8); backdrop-filter: blur(12px);
            border-left: 4px solid #0ff; padding: 25px;
            transition: right 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
            border-radius: 0 12px 12px 0;
        }
        #city-info.active { right: 30px; }
        #city-name { font-size: 1.8rem; color: #0ff; margin-bottom: 5px; font-weight: bold; }
        #city-country { font-size: 1rem; color: #aaa; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px;}
        #city-desc { color: #ddd; line-height: 1.5; font-size: 0.95rem; }
        
        #geo-btn {
            position: absolute; top: 30px; left: 30px;
            background: rgba(0, 255, 255, 0.05); border: 1px solid rgba(0, 255, 255, 0.5);
            color: #0ff; padding: 12px 20px; cursor: pointer; border-radius: 8px;
            text-transform: uppercase; letter-spacing: 1px; font-weight: bold;
            transition: all 0.3s ease;
        }
        #geo-btn:hover { background: rgba(0, 255, 255, 0.2); box-shadow: 0 0 20px rgba(0,255,255,0.4); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.5rem; color: #0ff; letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div id="loading">ИНИЦИАЛИЗАЦИЯ СИСТЕМЫ...</div>
    <button id="geo-btn">Моя локация</button>

    <div id="ui-panel">
        <h1>ISS ТЕЛЕМЕТРИЯ</h1>
        <div class="data-row"><span class="data-label">LAT:</span> <span class="data-value" id="iss-lat">--</span></div>
        <div class="data-row"><span class="data-label">LNG:</span> <span class="data-value" id="iss-lng">--</span></div>
        <div class="data-row"><span class="data-label">ALT:</span> <span class="data-value" id="iss-alt">--</span></div>
        <div class="data-row"><span class="data-label">VEL:</span> <span class="data-value" id="iss-vel">--</span></div>
    </div>

    <div id="city-info">
        <div id="city-name">--</div>
        <div id="city-country">--</div>
        <div id="city-desc">--</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- БАЗОВАЯ СЦЕНА ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 0, 3.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.04;
        controls.minDistance = 1.05; // Позволяет зумиться очень близко к поверхности
        controls.maxDistance = 8;
        controls.enablePan = false; // Отключаем смещение камеры, только вращение вокруг глобуса

        const EARTH_RADIUS = 1;
        let citiesData = [];
        let cityInstancedMesh;

        // Вспомогательная функция: Координаты в Vector3
        function latLongToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            return new THREE.Vector3(
                -(radius * Math.sin(phi) * Math.cos(theta)),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Вектор солнца
        function getSunVector() {
            const now = new Date();
            const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
            const declination = 23.45 * Math.sin((284 + dayOfYear) * (2 * Math.PI / 365));
            const utcHour = now.getUTCHours() + now.getUTCMinutes() / 60;
            return latLongToVector3(declination, (12 - utcHour) * 15, 1).normalize();
        }

        // --- ЗАГРУЗКА ТЕКСТУР И ГЛОБУС ---
        const textureLoader = new THREE.TextureLoader();
        
        // Для максимального качества рекомендую скачать 8k текстуры отсюда: https://www.solarsystemscope.com/textures/
        // И заменить ссылки на локальные (например './textures/8k_earth_daymap.jpg')
        const dayTexture = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg'); 
        const nightTexture = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-night.jpg');
        const cloudsTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png');

        const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128); // Высокая полигональность для гладкости
        
        const earthMaterial = new THREE.ShaderMaterial({
            uniforms: {
                dayTexture: { value: dayTexture },
                nightTexture: { value: nightTexture },
                sunDirection: { value: getSunVector() }
            },
            vertexShader: `
                varying vec2 vUv; varying vec3 vNormal;
                void main() { vUv = uv; vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform sampler2D dayTexture; uniform sampler2D nightTexture; uniform vec3 sunDirection;
                varying vec2 vUv; varying vec3 vNormal;
                void main() {
                    vec3 dayColor = texture2D(dayTexture, vUv).rgb;
                    vec3 nightColor = texture2D(nightTexture, vUv).rgb;
                    float intensity = dot(vNormal, sunDirection);
                    float blend = smoothstep(-0.2, 0.2, intensity);
                    gl_FragColor = vec4(mix(nightColor * 1.5, dayColor * max(intensity, 0.05), blend), 1.0);
                }
            `
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // ОБЛАКА (Добавляет глубину при зуме)
        const cloudGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.006, 64, 64);
        const cloudMaterial = new THREE.MeshLambertMaterial({
            map: cloudsTexture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(clouds);

        // Общее освещение для облаков
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        scene.add(sunLight);

        // --- МКС ---
        const issGeometry = new THREE.SphereGeometry(0.012, 16, 16);
        const issMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const issMesh = new THREE.Mesh(issGeometry, issMaterial);
        scene.add(issMesh);

        const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
        const trailGeo = new THREE.BufferGeometry();
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);

        let issTargetPos = new THREE.Vector3();
        let issCurrentPos = new THREE.Vector3();
        const trailPoints = [];

        async function fetchISSData() {
            try {
                const res = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
                const data = await res.json();
                
                document.getElementById('iss-lat').innerText = data.latitude.toFixed(4) + '°';
                document.getElementById('iss-lng').innerText = data.longitude.toFixed(4) + '°';
                document.getElementById('iss-alt').innerText = data.altitude.toFixed(2) + ' km';
                document.getElementById('iss-vel').innerText = data.velocity.toFixed(2) + ' km/h';

                const altitudeScale = 1 + (data.altitude / 6371); 
                issTargetPos.copy(latLongToVector3(data.latitude, data.longitude, EARTH_RADIUS * altitudeScale));
                
                if(issCurrentPos.length() === 0) {
                    issCurrentPos.copy(issTargetPos);
                    issMesh.position.copy(issCurrentPos);
                }
            } catch (e) { console.error('ISS Error:', e); }
        }
        setInterval(fetchISSData, 5000);
        fetchISSData();

        // --- ЗАГРУЗКА ГОРОДОВ ИЗ JSON (InstancedMesh для оптимизации) ---
        async function loadCities() {
            try {
                const res = await fetch('cities.json');
                citiesData = await res.json();

                const markerGeo = new THREE.SphereGeometry(0.004, 8, 8);
                const markerMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                
                // Создаем единый меш для ВСЕХ городов (хоть 10 000 штук)
                cityInstancedMesh = new THREE.InstancedMesh(markerGeo, markerMat, citiesData.length);
                const dummy = new THREE.Object3D();

                citiesData.forEach((city, i) => {
                    const pos = latLongToVector3(city.lat, city.lng, EARTH_RADIUS * 1.001);
                    dummy.position.copy(pos);
                    dummy.updateMatrix();
                    cityInstancedMesh.setMatrixAt(i, dummy.matrix);
                });

                scene.add(cityInstancedMesh);
                document.getElementById('loading').style.display = 'none';
            } catch (e) {
                console.error('Ошибка загрузки городов:', e);
                document.getElementById('loading').innerText = 'Ошибка загрузки cities.json';
            }
        }
        loadCities();

        // --- ВЗАИМОДЕЙСТВИЕ И КАМЕРА ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetCameraPos = new THREE.Vector3();
        let isZoomingToCity = false;

        window.addEventListener('click', (event) => {
            if (event.target.id === 'geo-btn' || !cityInstancedMesh) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(cityInstancedMesh);

            if (intersects.length > 0) {
                // Получаем ID инстанса, по которому кликнули
                const instanceId = intersects[0].instanceId;
                const city = citiesData[instanceId];
                
                // Получаем позицию кликнутого города
                const matrix = new THREE.Matrix4();
                cityInstancedMesh.getMatrixAt(instanceId, matrix);
                const targetPos = new THREE.Vector3().setFromMatrixPosition(matrix);

                // Задаем цель для камеры (чуть выше города)
                targetCameraPos.copy(targetPos).multiplyScalar(1.3);
                isZoomingToCity = true;

                // UI
                document.getElementById('city-name').innerText = city.name;
                document.getElementById('city-country').innerText = city.country;
                document.getElementById('city-desc').innerText = city.desc;
                document.getElementById('city-info').classList.add('active');
            } else {
                document.getElementById('city-info').classList.remove('active');
                isZoomingToCity = false;
            }
        });

        // --- ЛОКАЦИЯ ПОЛЬЗОВАТЕЛЯ ---
        let userMarker;
        document.getElementById('geo-btn').addEventListener('click', () => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(pos => {
                    const coords = latLongToVector3(pos.coords.latitude, pos.coords.longitude, EARTH_RADIUS * 1.002);
                    if(!userMarker) {
                        userMarker = new THREE.Mesh(
                            new THREE.SphereGeometry(0.006, 16, 16),
                            new THREE.MeshBasicMaterial({ color: 0xff0044 })
                        );
                        scene.add(userMarker);
                    }
                    userMarker.position.copy(coords);
                    targetCameraPos.copy(coords).multiplyScalar(1.5);
                    isZoomingToCity = true;
                });
            }
        });

        // --- АНИМАЦИЯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            // Вращение облаков для реализма
            clouds.rotation.y += 0.01 * delta;

            // Обновление солнца
            const sunVec = getSunVector();
            earthMaterial.uniforms.sunDirection.value = sunVec;
            sunLight.position.copy(sunVec).multiplyScalar(5);

            // Движение МКС
            if (issTargetPos.length() > 0) {
                issCurrentPos.lerp(issTargetPos, delta * 1.5);
                issMesh.position.copy(issCurrentPos);

                trailPoints.push(issCurrentPos.clone());
                if (trailPoints.length > 150) trailPoints.shift();
                trailGeo.setFromPoints(trailPoints);
            }

            // Плавный наезд камеры на город
            if (isZoomingToCity && targetCameraPos.length() > 0) {
                camera.position.lerp(targetCameraPos, delta * 2.5);
                controls.target.set(0,0,0);
                
                // Если приблизились достаточно, отключаем авто-зум
                if (camera.position.distanceTo(targetCameraPos) < 0.05) {
                    isZoomingToCity = false;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
